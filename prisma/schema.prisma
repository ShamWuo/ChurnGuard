generator client {
  provider = "prisma-client-js"
  // Use the library engine to avoid writing and renaming native query engine
  // binaries on filesystems that can lock files (e.g., OneDrive on Windows).
  // This reduces EPERM failures during `prisma generate`.
  engineType = "library"
}

datasource db {
  // NOTE: For local development we use SQLite. For production swap this to
  // provider = "postgresql" and set DATABASE_URL to a Postgres connection.
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

model User {
  id               Int            @id @default(autoincrement())
  email            String         @unique
  stripeCustomerId String?        @unique
  subscriptions    Subscription[]
  createdAt        DateTime       @default(now())
  updatedAt        DateTime       @updatedAt
}

model Subscription {
  id                  Int      @id @default(autoincrement())
  stripeSubscriptionId String   @unique
  status              String
  currentPeriodEnd    DateTime?
  cancelAtPeriodEnd   Boolean  @default(false)
  userId              Int?
  user                User?    @relation(fields: [userId], references: [id], onDelete: SetNull, onUpdate: Cascade)
  createdAt           DateTime @default(now())
  updatedAt           DateTime @updatedAt

  @@index([userId])
}

model DunningCase {
  id              Int      @id @default(autoincrement())
  stripeInvoiceId String   @unique
  stripeCustomerId String
  amountDue       Int
  currency        String
  status          String
  lastReminderAt  DateTime?
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  retryAttempts   RetryAttempt[]
  reminders       DunningReminder[]

  @@index([stripeCustomerId])
}

model RetryAttempt {
  id           Int      @id @default(autoincrement())
  dunningCaseId Int
  attemptNo    Int
  runAt        DateTime
  status       String   @default("QUEUED")
  note         String?
  dunningCase  DunningCase @relation(fields: [dunningCaseId], references: [id], onDelete: Cascade, onUpdate: Cascade)

  @@index([dunningCaseId])
}

model DunningReminder {
  id           Int      @id @default(autoincrement())
  dunningCaseId Int
  channel      String
  createdAt    DateTime @default(now())
  dunningCase  DunningCase @relation(fields: [dunningCaseId], references: [id], onDelete: Cascade, onUpdate: Cascade)

  @@index([dunningCaseId])
}

model RecoveryAttribution {
  id              Int      @id @default(autoincrement())
  stripeCustomerId String
  stripeInvoiceId String
  amountRecovered Int
  currency        String
  source          String
  createdAt       DateTime @default(now())

  @@index([stripeCustomerId])
  @@unique([stripeInvoiceId, source])
}

model Settings {
  id               Int @id @default(1)
  dunningBaseHours Int?
  dunningMaxAttempts Int?
  safeMode         Boolean @default(false)
  updatedAt        DateTime @updatedAt
}

model StripeEventLog {
  id      Int    @id @default(autoincrement())
  type    String
  raw     String
  createdAt DateTime @default(now())
  eventId String? @unique

  @@index([type, createdAt])
}

model AuditLog {
  id        Int      @id @default(autoincrement())
  actor     String?
  action    String
  details   String?
  createdAt DateTime @default(now())

  @@index([createdAt])
}

model CspReport {
  id       Int      @id @default(autoincrement())
  violated String?
  doc      String?
  blocked  String?
  ua       String?
  raw      String?
  headers  String?
  deletedAt DateTime?
  createdAt DateTime @default(now())

  @@index([createdAt])
}

// Typed enums (compatible with SQLite and Postgres). These give stronger
// typing in the Prisma client and help avoid magic strings in application code.

// Note: enums are provided to the application via `lib/enums` so local dev
// can continue to use SQLite while the code benefits from typed enum values.

